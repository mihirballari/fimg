[
  {
    "name": ".envrc",
    "path": ".envrc",
    "type": "file",
    "content": "# Auto-create venv if missing\nif [ ! -d .venv ]; then\n  uv venv\nfi\n\n# Auto-activate it (macOS uses python3)\nlayout python3 .venv\n"
  },
  {
    "name": ".gitignore",
    "path": ".gitignore",
    "type": "file",
    "content": ".DS_Store\n*.swp\n*.DS_Store?\n.DS_Store\n__pycache__/\n*.pyc\n\n# DO NOT COMMIT real phone lists\nlists/*.csv\n!lists/sample.csv\n"
  },
  {
    "name": "bin",
    "path": "bin",
    "type": "directory",
    "children": [
      {
        "name": "fimg",
        "path": "bin/fimg",
        "type": "file",
        "content": "#!/usr/bin/env sh\n# bin/fimg — explicit flags: -r reload, -c CLI send, -e edit, -h help\nset -eu\n\nresolve_dir() {\n  tgt=$1\n  while [ -L \"$tgt\" ]; do\n    dir=$(cd -P -- \"$(dirname -- \"$tgt\")\" && pwd)\n    link=$(readlink \"$tgt\")\n    case $link in /*) tgt=\"$link\" ;; *) tgt=\"$dir/$link\" ;; esac\n  done\n  cd -P -- \"$(dirname -- \"$tgt\")\" && pwd\n}\n\nSCRIPT_DIR=$(resolve_dir \"$0\")\nROOT_DIR=$(cd -P -- \"$SCRIPT_DIR/..\" && pwd)\n\nENGINE_TEST_PY=\"$ROOT_DIR/engine/test_send.py\"\nBLAST_PY=\"$ROOT_DIR/engine/blast.py\"\nEDIT_PY=\"$ROOT_DIR/engine/edit_list.py\"\nUI_LAUNCH=\"$ROOT_DIR/ui/landing.sh\"\n\nprint_help() {\n  cat <<EOF\nfimg — fast iMessage group\n\nUsage:\n  fimg -r\n      FULL reload: chmod +x *.sh/*.py; relink /usr/local/bin/fimg; refresh command cache.\n\n  fimg -c [all|actives|brothers|pledges] to <names> : <message>\n  fimg -c [all|actives|brothers|pledges] <names> : <message>\n      CLI send (no UI). Examples:  fimg -c to bay: yo   |  fimg -c pledges to all: hi\n\n  fimg -e r <list|path>      # remove entries (Tab-complete names; Enter=go, any other key=cancel)\n  fimg -e a <list|path>      # add a single entry (name → number → alias)\n      <list> may be: pledges | brothers | actives | all, or a CSV path.\n\n  fimg\n      Launch UI.\nEOF\n}\n\n# --- no args: launch UI\n[ $# -eq 0 ] && exec \"$UI_LAUNCH\"\n\ncase \"${1-}\" in\n-h | --help)\n  print_help\n  exit 0\n  ;;\n-r)\n  shift\n  echo \"[fimg] Reloading…\"\n  find \"$ROOT_DIR\" -type f -name '*.sh' -exec chmod +x {} \\; || true\n  find \"$ROOT_DIR\" -type f -name '*.py' -exec chmod +x {} \\; || true\n  # Relink\n  WANT=\"$ROOT_DIR/bin/fimg\"\n  if sudo ln -sf \"$WANT\" /usr/local/bin/fimg 2>/dev/null; then :; else\n    mkdir -p \"$HOME/bin\"\n    ln -sf \"$WANT\" \"$HOME/bin/fimg\"\n    case \":$PATH:\" in *\":$HOME/bin:\"*) : ;; *) export PATH=\"$HOME/bin:$PATH\" ;; esac\n  fi\n  hash -r 2>/dev/null || true\n  command -v rehash >/dev/null 2>&1 && rehash || true\n  echo \"✅ reloaded. which fimg => $(command -v fimg || echo not-found)\"\n  exit 0\n  ;;\n-c)\n  shift\n  [ -x \"$BLAST_PY\" ] || {\n    echo \"[fimg] blast not found: $BLAST_PY\" >&2\n    exit 2\n  }\n  exec \"$BLAST_PY\" \"$@\"\n  ;;\n-e)\n  shift\n  [ -f \"$EDIT_PY\" ] || {\n    echo \"[fimg] editor not found: $EDIT_PY\" >&2\n    exit 2\n  }\n  exec python3 \"$EDIT_PY\" \"$@\"\n  ;;\n*)\n  # anything else launches UI (prevents accidental editor invocation)\n  exec \"$UI_LAUNCH\" \"$@\"\n  ;;\nesac\n"
      }
    ]
  },
  {
    "name": "engine",
    "path": "engine",
    "type": "directory",
    "children": [
      {
        "name": "args.sh",
        "path": "engine/args.sh",
        "type": "file",
        "content": "# engine/args.sh\n# Parses: fimg to <targets> : <message>\n# Sets globals: TARGETS_STR, MESSAGE\n\nparse_cli() {\n  local raw=\"${*}\"\n  raw=\"${raw#to }\" # optional leading \"to \"\n\n  if printf '%s' \"$raw\" | grep -q ':'; then\n    TARGETS_STR=\"$(printf '%s' \"$raw\" | sed 's/[[:space:]]*:[[:space:]]*/:/' | cut -d: -f1)\"\n    MESSAGE=\"$(printf '%s' \"$raw\" | sed 's/[[:space:]]*:[[:space:]]*/:/' | cut -d: -f2-)\"\n  else\n    echo \"[fimg] Usage: fimg to <targets> : <message>\" >&2\n    return 2\n  fi\n\n  # trim quotes around targets\n  TARGETS_STR=\"${TARGETS_STR#\\\"}\"\n  TARGETS_STR=\"${TARGETS_STR%\\\"}\"\n  TARGETS_STR=\"${TARGETS_STR#\\'}\"\n  TARGETS_STR=\"${TARGETS_STR%\\'}\"\n\n  # decode literal \\n into real newlines\n  MESSAGE=\"$(printf '%b' \"${MESSAGE//\\\\n/\\\\n}\")\"\n}\n"
      },
      {
        "name": "blast.py",
        "path": "engine/blast.py",
        "type": "file",
        "content": "#!/usr/bin/env python3\n# engine/blast.py — CLI sender with pretty, colored, aligned recipient table\n\nimport csv, sys, re, subprocess, time, os, shlex, unicodedata\nfrom pathlib import Path\n\nROOT = Path(__file__).resolve().parents[1]\nLISTS = ROOT / \"lists\"\nENGINE = ROOT / \"engine\"\n\nCSV_MAP = {\n    \"all\":       LISTS / \"all.csv\",\n    \"actives\":   LISTS / \"brothers.csv\",\n    \"brothers\":  LISTS / \"brothers.csv\",\n    \"pledges\":   LISTS / \"pledges.csv\",\n}\nAS_PATH = ENGINE / \"send_imessage.applescript\"\n\nUSAGE = (\n    \"Usage:\\n\"\n    \"  fimg c [all|actives|brothers|pledges] to NAME1 NAME2 : MESSAGE\\n\"\n    \"  fimg c [all|actives|brothers|pledges] NAME1 NAME2 : MESSAGE\\n\"\n    \"  fimg c to NAME1 NAME2 : MESSAGE   # defaults to list = 'all'\\n\"\n)\n\n# -------------------- utils --------------------\n\ndef _norm(s: str) -> str:\n    s = unicodedata.normalize(\"NFKD\", s).encode(\"ascii\", \"ignore\").decode(\"ascii\")\n    s = re.sub(r\"[.,]\", \" \", s.lower())\n    return \" \".join(s.split())\n\ndef first_name(full: str) -> str:\n    n = _norm(full)\n    return n.split(\" \")[0] if n else \"\"\n\ndef color_enabled() -> bool:\n    return sys.stdout.isatty() and os.environ.get(\"NO_COLOR\") is None\n\ndef c(code: str) -> str:\n    return f\"\\033[{code}m\" if color_enabled() else \"\"\n\n# palette\nBOLD = c(\"1\")\nDIM = c(\"2\")\nFG_NAME = c(\"97\")      # bright white\nFG_NUM = c(\"36\")       # cyan\nFG_HEAD = c(\"95\")      # magenta\nFG_META = c(\"90\")      # bright black (gray)\nRESET = c(\"0\")\n\n# -------------------- data ---------------------\n\ndef load_contacts(csv_path: Path):\n    if not csv_path.exists():\n        sys.exit(f\"Roster CSV missing: {csv_path}\")\n    contacts = []\n    with open(csv_path, newline=\"\") as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            name = (row.get(\"name\") or row.get(\"Name\") or \"\").strip()\n            raw  = (row.get(\"number\") or row.get(\"Number\") or row.get(\"Phone\") or \"\").strip()\n            alias_raw = (row.get(\"alias\") or row.get(\"Alias\") or \"\").strip()\n            if not name or not raw:\n                continue\n            number = re.sub(r\"[^\\d+]\", \"\", raw)  # keep digits and '+'\n            aliases = [a.lower() for a in re.split(r\"[,\\s;/]+\", alias_raw) if a.strip()] if alias_raw else []\n            contacts.append({\n                \"name\": name,\n                \"first\": first_name(name),\n                \"number\": number,\n                \"name_l\": _norm(name),\n                \"aliases\": aliases,\n            })\n    return contacts\n\ndef dedup(people):\n    out, seen = [], set()\n    for c in people:\n        if c[\"number\"] not in seen:\n            out.append(c); seen.add(c[\"number\"])\n    return out\n\ndef parse(rest):\n    raw = \" \".join(rest).strip()\n    m = re.match(r'^(?:to\\s+)?(.+?)\\s*:\\s*(.+)$', raw, flags=re.IGNORECASE)\n    if not m: return None, None\n    names_raw, message = m.group(1).strip(), m.group(2).strip()\n    parts = []\n    for chunk in re.split(r'\\s*,\\s*', names_raw):\n        if chunk:\n            parts.extend(shlex.split(chunk))\n    tokens = [t for t in parts if t]\n    return tokens, message\n\ndef resolve(tokens, contacts):\n    if any(t.lower() == \"all\" for t in tokens):\n        return dedup(contacts), []\n    chosen, missing = [], []\n    for tok in tokens:\n        t = _norm(tok)\n        alias_hits = [c for c in contacts if t in c.get(\"aliases\", [])]\n        if alias_hits:\n            chosen.append(alias_hits[0]); continue\n        hits = [c for c in contacts\n                if t in c[\"name_l\"] or any(p.startswith(t) for p in c[\"name_l\"].split())]\n        if not hits:\n            missing.append(tok)\n        else:\n            starts = [c for c in hits if any(p.startswith(t) for p in c[\"name_l\"].split())]\n            chosen.append((starts or hits)[0])\n    return dedup(chosen), missing\n\ndef normalize_message(msg: str) -> str:\n    msg = (msg.replace('########', '\\n\\n')\n              .replace('####', '\\n\\n')\n              .replace('##', '\\n')\n              .replace('||||', '\\n\\n')\n              .replace('||', '\\n')\n              .replace('\\\\\\\\n', '\\n')\n              .replace('\\\\n', '\\n'))\n    msg = re.sub(r'\\n[ \\t]+', '\\n', msg)\n    return msg\n\ndef personalize(template: str, first_lower: str) -> str:\n    first_title = first_lower.capitalize()\n    msg = re.sub(r'(\\[(?:names?)\\]|\\{(?:names?)\\})', first_lower, template, flags=re.IGNORECASE)\n    def _n(m): return first_title if m.group(0) == '-N' else first_lower\n    msg = re.sub(r'(?<!\\S)-[nN](?=$|\\s|[.,;:!?])', _n, msg)\n    return msg\n\n# ---------------- pretty printing -------------\n\ndef print_header(list_key: str, csv_name: str, n: int):\n    h = f\"{BOLD}{FG_HEAD}List:{RESET} {BOLD}{list_key}{RESET}  {FG_META}|{RESET}  {FG_HEAD}CSV:{RESET} {csv_name}\"\n    print(h)\n    print(f\"{FG_META}Recipients ({n}):{RESET}\")\n\ndef print_recipients(resolved):\n    # compute column widths\n    idx_w = len(str(len(resolved)))\n    name_w = max(len(c[\"name\"]) for c in resolved) if resolved else 4\n    num_w = max(len(c[\"number\"]) for c in resolved) if resolved else 10\n\n    # header line\n    hdr = f\" {'#'.rjust(idx_w)}  {'Name'.ljust(name_w)}  {'Number'.rjust(num_w)} \"\n    print(f\"{FG_META}{hdr}{RESET}\")\n\n    # rows\n    for i, ctd in enumerate(resolved, 1):\n        idx = str(i).rjust(idx_w)\n        name = ctd[\"name\"].ljust(name_w)\n        num = ctd[\"number\"].rjust(num_w)\n        line = f\" {DIM}{idx}{RESET}  {BOLD}{FG_NAME}{name}{RESET}  {FG_NUM}{num}{RESET}\"\n        print(line)\n\n# -------------------- main --------------------\n\ndef confirm():\n    try:\n        import termios, tty\n        sys.stdout.write(\"\\nPress Enter to send; any other key to cancel... \")\n        sys.stdout.flush()\n        fd = sys.stdin.fileno()\n        old = termios.tcgetattr(fd)\n        try:\n            tty.setraw(fd); ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old)\n        print()\n        return ch in (\"\\r\", \"\\n\")\n    except Exception:\n        try: ans = input(\"\\nPress Enter to send; any other key to cancel... \")\n        except KeyboardInterrupt: print(); return False\n        return ans == \"\"\n\ndef main():\n    argv = sys.argv[1:]\n    list_key = \"all\"\n    rest = argv\n    if argv and argv[0].lower() in CSV_MAP:\n        list_key = argv[0].lower()\n        rest = argv[1:]\n\n    tokens, message = parse(rest)\n    if tokens is None or not message:\n        print(USAGE); sys.exit(1)\n\n    contacts = load_contacts(CSV_MAP[list_key])\n    message = normalize_message(message)\n    resolved, missing = resolve(tokens, contacts)\n\n    if not resolved:\n        print(\"No recipients matched.\")\n        if missing: print(\"Unmatched:\", \", \".join(missing))\n        sys.exit(1)\n\n    print_header(list_key, CSV_MAP[list_key].name, len(resolved))\n    print_recipients(resolved)\n\n    if missing:\n        print(f\"\\n{FG_META}Unmatched (ignored): {', '.join(missing)}{RESET}\")\n\n    print(f\"\\n{FG_HEAD}Message:{RESET}\\n\")\n    print(message)\n    print()\n\n    if not confirm():\n        print(\"Canceled.\"); return\n\n    if not AS_PATH.exists():\n        sys.exit(f\"AppleScript missing: {AS_PATH}\")\n    print(f\"\\nSending {len(resolved)} message(s)...\")\n\n    sent = failed = 0\n    failures = []\n    for c in resolved:\n        per = personalize(message, c[\"first\"])\n        print(f\"  -> {c['name']} … \", end=\"\", flush=True)\n        proc = subprocess.run([\"osascript\", str(AS_PATH), c[\"number\"], per],\n                              text=True, capture_output=True)\n        if proc.returncode == 0:\n            print(\"✔\"); sent += 1\n        else:\n            print(\"✖\"); failed += 1; failures.append(c[\"name\"])\n        time.sleep(0.6)\n\n    print(f\"\\n✅ Done. Sent: {sent}  |  Failed: {failed}\")\n    if failures:\n        print(\"Failed:\", \", \".join(failures))\n\nif __name__ == \"__main__\":\n    main()\n\n"
      },
      {
        "name": "csv.sh",
        "path": "engine/csv.sh",
        "type": "file",
        "content": "# engine/csv.sh\n# Reads CSV rows (name,number,alias) and calls: cb name number alias\ncsv_each_row() {\n  local file=\"$1\" cb=\"$2\"\n  [ -f \"$file\" ] || return 0\n  awk -F',' '\n    /^[[:space:]]*#/ { next }\n    /^[[:space:]]*$/ { next }\n    {\n      name=$1; number=$2; alias=$3\n      gsub(/^[[:space:]]+|[[:space:]]+$/, \"\", name)\n      gsub(/^[[:space:]]+|[[:space:]]+$/, \"\", number)\n      gsub(/^[[:space:]]+|[[:space:]]+$/, \"\", alias)\n      print name \",\" number \",\" alias\n    }' \"$file\" | while IFS=',' read -r _n _p _a; do\n    \"$cb\" \"$_n\" \"$_p\" \"$_a\"\n  done\n}\n"
      },
      {
        "name": "edit_list.py",
        "path": "engine/edit_list.py",
        "type": "file",
        "content": "#!/usr/bin/env python3\n# engine/edit_list.py — roster editor used by: fimg -e [a|r] [list]\n# CSV schema: name,number,alias\n\nimport sys, csv, re, os, unicodedata, readline\nfrom pathlib import Path\nfrom typing import List, Dict, Tuple, Optional\n\n# Force line-buffered stdout so prints appear before raw key reads\ntry:\n    sys.stdout.reconfigure(line_buffering=True)\nexcept Exception:\n    pass\n\n# ---------- colors ----------\ndef _color_on() -> bool:\n    return sys.stdout.isatty() and os.environ.get(\"NO_COLOR\") is None\ndef C(code: str) -> str:\n    return f\"\\033[{code}m\" if _color_on() else \"\"\n\nBOLD, DIM = C(\"1\"), C(\"2\")\nHDR, META, OK, WARN, ERR = C(\"95\"), C(\"90\"), C(\"32\"), C(\"33\"), C(\"31\")\nNAME, NUM, RST = C(\"97\"), C(\"36\"), C(\"0\")\n\n# ---------- terminal helpers ----------\ndef _cls():\n    \"\"\"Clear terminal and move cursor to top-left.\"\"\"\n    sys.stdout.write(\"\\033[2J\\033[H\")\n    sys.stdout.flush()\n\ndef _read_single_key(prompt: str) -> str:\n    import termios, tty\n    sys.stdout.write(prompt); sys.stdout.flush()\n    fd = sys.stdin.fileno()\n    old = termios.tcgetattr(fd)\n    try:\n        tty.setraw(fd)\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old)\n    sys.stdout.write(\"\\n\"); sys.stdout.flush()\n    return ch\n\ndef confirm_enter_else_cancel(prompt: str) -> bool:\n    return _read_single_key(prompt) in (\"\\r\", \"\\n\")\n\n# ---------- paths & list resolution ----------\nROOT  = Path(__file__).resolve().parents[1]\nLISTS = ROOT / \"lists\"\n\ndef resolve_csv(arg: str) -> Path:\n    key = (arg or \"\").lower()\n    if key in {\"pledges\", \"brothers\", \"actives\", \"all\"}:\n        file_key = \"brothers\" if key in {\"brothers\", \"actives\"} else key\n        return (LISTS / f\"{file_key}.csv\").resolve()\n    p = Path(arg).expanduser()\n    if p.suffix == \"\": p = p.with_suffix(\".csv\")\n    return p.resolve()\n\ndef list_choices() -> List[Path]:\n    LISTS.mkdir(parents=True, exist_ok=True)\n    return sorted(LISTS.glob(\"*.csv\"))\n\ndef _pick_one_key(max_n: int, prompt: str) -> Optional[int]:\n    \"\"\"\n    If max_n <= 9, read a single key (1..max_n) without Enter.\n    Otherwise fall back to full-line input so you can type multi-digit.\n    Returns 1-based index or None if canceled/invalid.\n    \"\"\"\n    if max_n <= 9:\n        ch = _read_single_key(prompt)\n        if ch.isdigit():\n            i = int(ch)\n            return i if 1 <= i <= max_n else None\n        if ch.lower() == 'q':\n            return None\n        return None\n    else:\n        try:\n            s = input(prompt).strip()\n        except (KeyboardInterrupt, EOFError):\n            return None\n        if s.lower() == 'q' or not s.isdigit():\n            return None\n        i = int(s)\n        return i if 1 <= i <= max_n else None\n\ndef pick_from(paths: List[Path], title: str) -> Optional[Path]:\n    _cls()\n    if not paths:\n        print(f\"{WARN}No lists found.{RST}\")\n        return None\n    print(f\"{HDR}{title}{RST}\")\n    for i, p in enumerate(paths, 1):\n        print(f\" {DIM}{i:>2}{RST}) {p.stem}  {META}({p.name}){RST}\")\n    max_n = len(paths)\n    sys.stdout.flush()\n    idx = _pick_one_key(max_n, f\"{BOLD}Choose [1-{max_n}]:{RST} \")\n    if idx is None:\n        print(\"Canceled.\")\n        return None\n    return paths[idx - 1]\n\n# ---------- util & IO ----------\ndef _norm(s: str) -> str:\n    s = unicodedata.normalize(\"NFKD\", s).encode(\"ascii\", \"ignore\").decode(\"ascii\")\n    s = re.sub(r\"[.,]\", \" \", s.lower())\n    return \" \".join(s.split())\n\ndef _initials(name_norm: str) -> str:\n    parts = [p for p in name_norm.split() if p]\n    return \"\".join(p[0] for p in parts)\n\ndef load_contacts(csv_path: Path) -> List[Dict]:\n    if not csv_path.exists(): return []\n    out = []\n    with open(csv_path, newline=\"\") as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            name = (row.get(\"name\") or row.get(\"Name\") or \"\").strip()\n            raw  = (row.get(\"number\") or row.get(\"Number\") or row.get(\"Phone\") or \"\").strip()\n            alias_raw = (row.get(\"alias\") or row.get(\"Alias\") or \"\").strip()\n            if not name or not raw: continue\n            number = re.sub(r\"[^\\d+]\", \"\", raw)\n            name_l = _norm(name)\n            out.append({\n                \"name\": name,\n                \"number\": number,\n                \"alias\": alias_raw,\n                \"name_l\": name_l,\n                \"first_l\": name_l.split()[0] if name_l else \"\",\n                \"last_l\":  name_l.split()[-1] if name_l else \"\",\n                \"inits\":   _initials(name_l),\n                \"aliases\": [a.lower() for a in re.split(r\"[,\\s;/]+\", alias_raw) if a.strip()] if alias_raw else [],\n            })\n    return out\n\ndef write_csv_no_backup(csv_path: Path, rows: List[Dict]):\n    tmp = csv_path.with_suffix(csv_path.suffix + \".tmp\")\n    with open(tmp, \"w\", newline=\"\") as f:\n        w = csv.DictWriter(f, fieldnames=[\"name\",\"number\",\"alias\"])\n        w.writeheader()\n        for r in sorted(rows, key=lambda r: r[\"name\"].lower()):\n            w.writerow({\"name\": r[\"name\"], \"number\": r[\"number\"], \"alias\": r.get(\"alias\",\"\")})\n        f.flush(); os.fsync(f.fileno())\n    os.replace(tmp, csv_path)\n\n# ---------- pretty print ----------\ndef print_header(title_left: str, csv_name: str):\n    print(f\"{HDR}List:{RST} {title_left}  {META}|{RST}  {HDR}CSV:{RST} {csv_name}\")\n\ndef print_table(rows: List[Dict], caption: str):\n    print(f\"{META}{caption}{RST}\")\n    if not rows:\n        print(f\"{META}(none){RST}\")\n        return\n    idx_w = len(str(len(rows)))\n    name_w = max(len(r[\"name\"]) for r in rows)\n    num_w  = max(len(r[\"number\"]) for r in rows)\n    print(f\"{META} {'#'.rjust(idx_w)}  {'Name'.ljust(name_w)}  {'Number'.rjust(num_w)} {RST}\")\n    for i, r in enumerate(rows, 1):\n        idx  = str(i).rjust(idx_w)\n        name = r[\"name\"].ljust(name_w)\n        num  = r[\"number\"].rjust(num_w)\n        print(f\" {DIM}{idx}{RST}  {BOLD}{NAME}{name}{RST}  {NUM}{num}{RST}\")\n\n# ---------- matching ----------\ndef score_match(tok: str, c: Dict) -> Tuple[int,int]:\n    t = _norm(tok)\n    if not t: return (-1, 0)\n    if t in c[\"aliases\"]:                              return (100, len(c[\"name\"]))\n    if t == c[\"name_l\"]:                               return (95, len(c[\"name\"]))\n    if t == c[\"first_l\"] or t == c[\"last_l\"]:          return (90, len(c[\"name\"]))\n    if len(t) <= 3 and t == c[\"inits\"]:                return (85, len(c[\"name\"]))\n    if any(p.startswith(t) for p in c[\"name_l\"].split()): return (70, len(c[\"name\"]))\n    if t in c[\"name_l\"]:                               return (50, len(c[\"name\"]))\n    return (-1, 0)\n\ndef resolve_tokens(tokens: List[str], people: List[Dict]) -> Tuple[List[Dict], List[str]]:\n    chosen, missing = [], []\n    seen_numbers = set()\n    for tok in tokens:\n        best, best_sc = None, (-1, 0)\n        for c in people:\n            sc = score_match(tok, c)\n            if sc > best_sc:\n                best_sc, best = sc, c\n        if best_sc[0] < 0:\n            missing.append(tok)\n        else:\n            if best[\"number\"] not in seen_numbers:\n                seen_numbers.add(best[\"number\"])\n                chosen.append(best)\n    return chosen, missing\n\n# ---------- readline autocomplete ----------\ndef setup_readline(people: List[Dict]):\n    try:\n        cands = []\n        for r in people:\n            cands.append(r[\"name\"]); cands.extend(r[\"aliases\"])\n        cands = sorted(set(cands), key=str.lower)\n        class NameCompleter:\n            def __init__(self, c): self.c=c\n            def complete(self, text, state):\n                buf = readline.get_line_buffer()\n                parts = re.split(r\"[,\\s]+\", buf.rstrip())\n                pref = parts[-1] if parts else \"\"\n                m = [x for x in self.c if x.lower().startswith(pref.lower())]\n                try: return m[state]\n                except IndexError: return None\n        readline.set_completer_delims(\" \\t\\n\")\n        readline.set_completer(NameCompleter(cands).complete)\n        doc = getattr(readline, \"__doc__\", \"\") or \"\"\n        if \"libedit\" in doc: readline.parse_and_bind(\"bind ^I rl_complete\")\n        else:                readline.parse_and_bind(\"tab: complete\")\n    except Exception:\n        pass\n\n# ---------- actions ----------\ndef action_remove(csv_path: Path):\n    # Screen 1: header + input\n    _cls()\n    people = load_contacts(csv_path)\n    print_header(csv_path.stem, csv_path.name)\n    if not people:\n        print(f\"{ERR}List is empty; nothing to remove.{RST}\"); return\n\n    setup_readline(people)\n    print(); print(f\"{HDR}Removing{RST} Names\\n\")\n    try:\n        line = input(f\"{BOLD}Name(s):{RST} \").strip()\n    except (KeyboardInterrupt, EOFError):\n        print(\"\\nCanceled.\"); return\n    tokens = [t for t in re.split(r\"[,\\s]+\", line) if t]\n    if not tokens: print(\"No names entered. Canceled.\"); return\n\n    all_requested = any(_norm(t) == \"all\" for t in tokens)\n    if all_requested:\n        chosen, missing = people[:], [t for t in tokens if _norm(t) != \"all\"]\n    else:\n        chosen, missing = resolve_tokens(tokens, people)\n\n    # Screen 2: preview table\n    _cls()\n    print_header(csv_path.stem, csv_path.name)\n    if missing: print(f\"{WARN}Unmatched:{RST} \" + \", \".join(missing))\n    print(); print_table(chosen, caption=f\"Recipients to remove ({len(chosen)}):\"); print()\n    if not confirm_enter_else_cancel(f\"{WARN}Press Enter to remove{RST}, or any other key to cancel: \"):\n        print(\"Canceled.\"); return\n\n    # Screen 3: progress\n    _cls()\n    n = len(chosen)\n    print_header(csv_path.stem, csv_path.name)\n    print(f\"{WARN}removing {n} person..{RST}\")\n    for r in chosen: print(f\"  -> {r['name']}\")\n\n    # Screen 4: commit + final summary\n    if all_requested:\n        ch = _read_single_key(f\"{WARN}Delete file {csv_path.name} too? (y/N): \")\n        if ch in (\"y\",\"Y\"):\n            try: os.remove(csv_path)\n            except FileNotFoundError: pass\n            _cls(); print_header(csv_path.stem, csv_path.name)\n            print(f\"{OK}removed {n} | 0 left in {csv_path.name}{RST}\")\n            return\n        write_csv_no_backup(csv_path, [])\n        _cls(); print_header(csv_path.stem, csv_path.name)\n        print(f\"{OK}removed {n} | 0 left in {csv_path.name}{RST}\")\n        return\n\n    nums = {c[\"number\"] for c in chosen}\n    remaining = [r for r in people if r[\"number\"] not in nums]\n    write_csv_no_backup(csv_path, remaining)\n    _cls(); print_header(csv_path.stem, csv_path.name)\n    print(f\"{OK}removed {n} | {len(remaining)} left in {csv_path.name}{RST}\")\n\ndef _prompt_one_person(i: int) -> Optional[Dict]:\n    try:\n        name = input(f\"{BOLD}[{i}] Name:{RST} \").strip()\n        if not name: return None\n        number = input(f\"{BOLD}[{i}] Number (+15551234567 or digits):{RST} \").strip()\n        number = re.sub(r\"[^\\d+]\", \"\", number)\n        alias  = input(f\"{BOLD}[{i}] Alias(es) [optional, comma-separated]:{RST} \").strip().lower()\n    except (KeyboardInterrupt, EOFError):\n        print(\"\\nCanceled.\"); return None\n    if not number:\n        print(f\"{ERR}Number is required; entry skipped.{RST}\")\n        return None\n    return {\"name\": name, \"number\": number, \"alias\": alias}\n\ndef action_add(csv_path: Path):\n    # Screen 1: header + how many\n    _cls()\n    people = load_contacts(csv_path)\n    print_header(csv_path.stem, csv_path.name)\n    print(); print(f\"{HDR}Add entry{RST}\")\n\n    try:\n        cnt_raw = input(f\"{BOLD}# people to add [default 1]:{RST} \").strip()\n    except (KeyboardInterrupt, EOFError):\n        print(\"\\nCanceled.\"); return\n    count = 1 if cnt_raw == \"\" else (int(cnt_raw) if cnt_raw.isdigit() and int(cnt_raw) > 0 else 1)\n\n    # Screen 2: prompts per person (stays on same screen while prompting)\n    staged: List[Dict] = []\n    for i in range(1, count+1):\n        ent = _prompt_one_person(i)\n        if ent:\n            if any(p[\"number\"] == ent[\"number\"] for p in people) or any(s[\"number\"] == ent[\"number\"] for s in staged):\n                print(f\"{WARN}That number already exists; skipped.{RST}\")\n            else:\n                staged.append(ent)\n\n    if not staged:\n        print(\"No valid entries. Canceled.\"); return\n\n    # Screen 3: staged preview\n    _cls()\n    print_header(csv_path.stem, csv_path.name)\n    print_table(staged, caption=f\"Entries to add ({len(staged)}):\")\n    if not confirm_enter_else_cancel(f\"{OK}Press Enter to save{RST}, or any other key to cancel: \"):\n        print(\"Canceled.\"); return\n\n    # Screen 4: progress\n    _cls()\n    print_header(csv_path.stem, csv_path.name)\n    print(f\"{OK}adding {len(staged)} person..{RST}\")\n    for s in staged: print(f\"  -> {s['name']}\")\n\n    # Commit + Screen 5: final summary\n    for s in staged:\n        people.append({\n            \"name\": s[\"name\"], \"number\": s[\"number\"], \"alias\": s[\"alias\"],\n            \"name_l\": _norm(s[\"name\"]),\n            \"first_l\": _norm(s[\"name\"]).split()[0] if s[\"name\"] else \"\",\n            \"last_l\":  _norm(s[\"name\"]).split()[-1] if s[\"name\"] else \"\",\n            \"inits\":   \"\".join(w[0] for w in _norm(s[\"name\"]).split() if w),\n            \"aliases\": [a for a in re.split(r\"[,\\s;/]+\", s[\"alias\"]) if a],\n        })\n    write_csv_no_backup(csv_path, people)\n    _cls(); print_header(csv_path.stem, csv_path.name)\n    print(f\"{OK}added {len(staged)} | {len(people)} left in {csv_path.name}{RST}\")\n\n# ---------- menus ----------\ndef menu_add() -> Optional[Path]:\n    _cls()\n    print(f\"{HDR}Add to{RST}\")\n    print(\" 1) Existing list\")\n    print(\" 2) Create new list\")\n    print(\" q) Quit\")\n    sys.stdout.flush()\n    ch = _read_single_key(f\"{BOLD}Choose:{RST} \").lower()\n    if ch == \"1\":\n        return pick_from(list_choices(), \"Choose list\")\n    if ch == \"2\":\n        _cls()\n        name = input(f\"{BOLD}New list name (no extension):{RST} \").strip()\n        if not name:\n            print(\"Canceled.\"); return None\n        p = LISTS / f\"{name}.csv\"\n        if not p.exists():\n            write_csv_no_backup(p, [])\n        else:\n            print(f\"{WARN}List already exists; using it.{RST}\")\n        return p\n    print(\"Canceled.\"); return None\n\ndef menu_remove() -> Optional[Path]:\n    _cls()\n    print(f\"{HDR}Remove from{RST}\")\n    print(\" 1) Existing list\")\n    print(\" 2) Delete existing list\")\n    print(\" q) Quit\")\n    sys.stdout.flush()\n    ch = _read_single_key(f\"{BOLD}Choose:{RST} \").lower()\n    if ch == \"1\":\n        return pick_from(list_choices(), \"Choose list\")\n    if ch == \"2\":\n        p = pick_from(list_choices(), \"Delete which list\")\n        if not p:\n            return None\n        k = _read_single_key(f\"{WARN}Delete file {p.name}? (y/N): \")\n        if k in (\"y\", \"Y\"):\n            try:\n                os.remove(p)\n            except FileNotFoundError:\n                pass\n            _cls()\n            print(f\"{OK}deleted {p.name}{RST}\")\n        else:\n            _cls()\n            print(\"Canceled delete.\")\n        return None\n    print(\"Canceled.\"); return None\n\ndef menu_root() -> Optional[Tuple[str, Optional[Path]]]:\n    _cls()\n    print(f\"{HDR}Edit lists{RST}\")\n    print(\" 1) Add to\")\n    print(\" 2) Remove from\")\n    print(\" q) Quit\")\n    sys.stdout.flush()\n    ch = _read_single_key(f\"{BOLD}Choose:{RST} \").lower()\n    if ch == \"1\":\n        p = menu_add()\n        return (\"a\", p) if p else None\n    if ch == \"2\":\n        p = menu_remove()\n        return (\"r\", p) if p else None\n    print(\"Canceled.\")\n    return None\n\n# ---------- CLI ----------\ndef main():\n    argv = sys.argv[1:]\n\n    # If no args: open root menu (Add / Remove)\n    if not argv:\n        sel = menu_root()\n        if not sel:\n            return\n        mode, csv_path = sel\n        if not csv_path:\n            return\n        if mode == \"a\":\n            action_add(csv_path)\n        else:\n            action_remove(csv_path)\n        return\n\n    # With args: direct modes\n    if argv[0] not in (\"r\", \"a\"):\n        print(\"Usage: edit_list.py r|a [<list-or-path>]\"); sys.exit(1)\n\n    mode = argv[0]\n    if len(argv) >= 2:\n        csv_path = resolve_csv(argv[1])\n    else:\n        csv_path = menu_add() if mode == \"a\" else menu_remove()\n        if csv_path is None:\n            return\n\n    if mode == \"r\":\n        action_remove(csv_path)\n    else:\n        action_add(csv_path)\n\nif __name__ == \"__main__\":\n    main()\n\n"
      },
      {
        "name": "lists.sh",
        "path": "engine/lists.sh",
        "type": "file",
        "content": "# engine/lists.sh\n# Resolves comma-separated targets using ~/fimg/lists/*.csv\n# Produces arrays: RESOLVED_NAMES[], RESOLVED_HANDLES[]\n\n. \"$(dirname \"${BASH_SOURCE[0]}\")/csv.sh\"\n\nRESOLVED_NAMES=()\nRESOLVED_HANDLES=()\n\n_lower() { printf '%s' \"$1\" | tr '[:upper:]' '[:lower:]'; }\n_trim() { printf '%s' \"$1\" | sed 's/^[[:space:]]\\+//; s/[[:space:]]\\+$//'; }\n\n_is_handle() {\n  case \"$1\" in\n  *\"@\"* | *[0-9]*) return 0 ;;\n  esac\n  return 1\n}\n\ndeclare -gA __NAME_FOR_KEY\ndeclare -gA __HANDLE_FOR_KEY\n\n__collect_row() {\n  local name=\"$1\" number=\"$2\" alias=\"$3\"\n  [ -n \"$name\" ] || return\n  local lname=\"$(_lower \"$name\")\"\n  local lalias=\"$(_lower \"$alias\")\"\n\n  __NAME_FOR_KEY[\"$lname\"]=\"$name\"\n  __HANDLE_FOR_KEY[\"$lname\"]=\"$number\"\n\n  # also index first/last tokens\n  local first=\"${lname%% *}\"\n  local last=\"${lname##* }\"\n  __NAME_FOR_KEY[\"$first\"]=\"$name\"\n  __HANDLE_FOR_KEY[\"$first\"]=\"$number\"\n  __NAME_FOR_KEY[\"$last\"]=\"$name\"\n  __HANDLE_FOR_KEY[\"$last\"]=\"$number\"\n\n  if [ -n \"$lalias\" ]; then\n    __NAME_FOR_KEY[\"$lalias\"]=\"$name\"\n    __HANDLE_FOR_KEY[\"$lalias\"]=\"$number\"\n  fi\n}\n\n_build_maps() {\n  __NAME_FOR_KEY=()\n  __HANDLE_FOR_KEY=()\n  local dir=\"${FIMG_LISTS_DIR:-$HOME/fimg/lists}\"\n  [ -d \"$dir\" ] || return 0\n  for f in \"$dir\"/*.csv; do\n    [ -e \"$f\" ] || continue\n    csv_each_row \"$f\" __collect_row\n  done\n}\n\nresolve_targets_from_lists() {\n  local input=\"$1\"\n  RESOLVED_NAMES=()\n  RESOLVED_HANDLES=()\n  _build_maps\n\n  IFS=',' read -r -a items <<<\"$input\"\n  declare -A seen=()\n  for raw in \"${items[@]}\"; do\n    local item=\"$(_trim \"$raw\")\"\n    [ -n \"$item\" ] || continue\n\n    local name handle key=\"$(_lower \"$item\")\"\n\n    if _is_handle \"$item\"; then\n      name=\"$item\"\n      handle=\"$item\"\n    else\n      if [ -n \"${__NAME_FOR_KEY[$key]:-}\" ]; then\n        name=\"${__NAME_FOR_KEY[$key]}\"\n        handle=\"${__HANDLE_FOR_KEY[$key]}\"\n      else\n        # substring fallback (matches parts of full name or alias already indexed)\n        for k in \"${!__NAME_FOR_KEY[@]}\"; do\n          if [[ \"$k\" == *\"$key\"* ]]; then\n            name=\"${__NAME_FOR_KEY[$k]}\"\n            handle=\"${__HANDLE_FOR_KEY[$k]}\"\n            break\n          fi\n        done\n      fi\n      [ -n \"$name\" ] || name=\"$item\"\n      [ -n \"$handle\" ] || handle=\"$item\"\n    fi\n\n    local hkey=\"$(_lower \"$handle\")\"\n    [ -n \"${seen[$hkey]:-}\" ] && continue\n    seen[$hkey]=1\n    RESOLVED_NAMES+=(\"$name\")\n    RESOLVED_HANDLES+=(\"$handle\")\n  done\n}\n"
      },
      {
        "name": "preview.sh",
        "path": "engine/preview.sh",
        "type": "file",
        "content": "# engine/preview.sh\n. \"$(dirname \"${BASH_SOURCE[0]}\")/term.sh\"\n\nBOLD=\"\\033[1m\"\nDIM=\"\\033[2m\"\nRST=\"\\033[0m\"\n\npreview_and_confirm() {\n  local message=\"$1\"\n  shift\n  local recipients=(\"$@\")\n\n  local title=\"Message preview:\"\n  local maxw=${#title}\n  while IFS= read -r line; do\n    [ ${#line} -gt $maxw ] && maxw=${#line}\n  done < <(printf '%s\\n' \"$message\")\n  maxw=$((maxw + 2))\n\n  local rule\n  rule=\"$(printf '%*s' \"$maxw\" | tr ' ' '─')\"\n  printf '\\n' # top spacing\n  printf '┌%s┐\\n' \"$rule\"\n  printf '│ %s%*s│\\n' \"$title\" $((maxw - ${#title} - 1)) \"\"\n  while IFS= read -r line; do\n    printf '│ %s%*s│\\n' \"$line\" $((maxw - ${#line} - 1)) \"\"\n  done < <(printf '%s\\n' \"$message\")\n  printf '└%s┘\\n' \"$rule\"\n\n  printf '\\n'\n  printf '%b%s%b\\n' \"$BOLD\" \"send to:\" \"$RST\"\n  printf '%s\\n\\n' \"$(printf '%s ' \"${recipients[@]}\")\"\n  printf '%b%s%b' \"$DIM\" \"Press Enter to send; any other key to cancel...\" \"$RST\"\n  local k\n  k=\"$(term_read_key)\"\n  printf '\\n'\n  [ \"$k\" = $'\\n' ] || [ \"$k\" = $'\\r' ]\n}\n"
      },
      {
        "name": "send.sh",
        "path": "engine/send.sh",
        "type": "file",
        "content": "# engine/send.sh\nsend_one() {\n  local handle=\"$1\"\n  shift\n  local message=\"$*\"\n  /usr/bin/osascript \"$HOME/fimg/engine/send_imessage.applescript\" \"$handle\" \"$message\"\n}\n"
      },
      {
        "name": "send_imessage.applescript",
        "path": "engine/send_imessage.applescript",
        "type": "file",
        "content": "on run {targetPhone, targetMessage}\n    tell application \"Messages\"\n        set svc to first service whose service type is iMessage\n        set buddyRef to buddy targetPhone of svc\n        if targetMessage is not \"\" then\n            send targetMessage to buddyRef\n        end if\n    end tell\nend run\n"
      },
      {
        "name": "term.sh",
        "path": "engine/term.sh",
        "type": "file",
        "content": "# engine/term.sh\nterm_read_key() {\n  stty -echo -icanon time 0 min 1 2>/dev/null\n  dd bs=1 count=1 2>/dev/null\n  stty sane 2>/dev/null\n}\n"
      },
      {
        "name": "test_send.py",
        "path": "engine/test_send.py",
        "type": "file",
        "content": "#!/usr/bin/env python3\nimport csv, os, sys, subprocess, termios, tty, time, threading\n\nLISTS_DIR = os.environ.get(\"FIMG_LISTS_DIR\", os.path.expanduser(\"~/fimg/lists\"))\nAS_PATH   = os.path.expanduser(\"~/fimg/engine/send_imessage.applescript\")\n\n# --- ANSI styles ---\nRST   = \"\\033[0m\"\nBOLD  = \"\\033[1m\"\nDIM   = \"\\033[2m\"\nGREEN = \"\\033[32m\"\nRED   = \"\\033[31m\"\nBLUE  = \"\\033[34m\"\n\nCHECK = \"✔\"\nCROSS = \"✖\"\nSPIN  = list(\"⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏\")\n\ndef read_key():\n    fd = sys.stdin.fileno()\n    old = termios.tcgetattr(fd)\n    try:\n        tty.setraw(fd)\n        ch = sys.stdin.read(1)\n    finally:\n        termios.tcsetattr(fd, termios.TCSADRAIN, old)\n    return ch\n\ndef parse_cli(argv):\n    if len(argv) < 2:\n        raise SystemExit(\"Usage: test_send.py to <targets> : <message>\")\n    raw = \" \".join(argv[1:])\n    # accept \"to bay : yo\" or \"to bay: yo\"\n    if raw.startswith(\"to \"):\n        raw = raw[3:]\n    if \":\" not in raw:\n        raise SystemExit(\"Usage: test_send.py to <targets> : <message>\")\n    # normalize single colon split (with or without spaces around)\n    parts = raw.split(\":\", 1)\n    targets = parts[0].strip().strip('\"').strip(\"'\")\n    message = parts[1].strip().replace(\"\\\\n\", \"\\n\")\n    return targets, message\n\ndef load_entries():\n    entries = []\n    if not os.path.isdir(LISTS_DIR):\n        return entries\n    for fn in os.listdir(LISTS_DIR):\n        if not fn.lower().endswith(\".csv\"): continue\n        path = os.path.join(LISTS_DIR, fn)\n        with open(path, newline='') as f:\n            r = csv.DictReader(f)\n            for row in r:\n                name = (row.get(\"name\") or \"\").strip()\n                number = (row.get(\"number\") or \"\").strip()\n                alias = (row.get(\"alias\") or \"\").strip()\n                if not name: continue\n                tokens = [t for t in name.lower().split() if t]\n                entries.append({\n                    \"name\": name,\n                    \"number\": number,\n                    \"alias\": alias.lower(),\n                    \"tokens\": tokens,\n                    \"name_l\": name.lower()\n                })\n    return entries\n\ndef is_handle(s):\n    s2 = s.replace(\" \", \"\")\n    return any(ch.isdigit() for ch in s2) or (\"@\" in s2)\n\ndef resolve_targets(targets_str, entries):\n    want = [x.strip() for x in targets_str.split(\",\") if x.strip()]\n    out = []\n    seen = set()\n    for w in want:\n        if is_handle(w):\n            key = w.lower()\n            if key in seen: continue\n            out.append((w, w)); seen.add(key); continue\n        wl = w.lower()\n        hit = next((e for e in entries if e[\"alias\"] == wl and e[\"alias\"]), None)\n        if not hit:\n            hit = next((e for e in entries if e[\"name_l\"] == wl), None)\n        if not hit:\n            hit = next((e for e in entries if wl in e[\"tokens\"]), None)\n        if not hit:\n            hit = next((e for e in entries if wl in e[\"name_l\"]), None)\n        if hit:\n            handle = hit[\"number\"] or hit[\"name\"]\n            key = handle.lower()\n            if key not in seen:\n                out.append((hit[\"name\"], handle)); seen.add(key)\n        else:\n            key = wl\n            if key not in seen:\n                out.append((w, w)); seen.add(key)\n    return out\n\ndef box_preview(message, names):\n    # Plain, no box — just show the message and recipients, then confirm.\n    print()  # top spacing\n    print(\"Message:\")\n    print(message if message.strip() else \"(empty)\")\n    print()\n    print(\"send to:\")\n    print(\" \".join(names))\n    print()\n    print(DIM + \"Press Enter to send; any other key to cancel...\" + RST, end=\"\", flush=True)\n    ch = read_key()\n    print()\n    return ch in (\"\\n\", \"\\r\")\n\ndef run_osascript(handle, message):\n    # Use Popen so we can animate while it runs\n    return subprocess.Popen(\n        [\"osascript\", AS_PATH, handle, message],\n        text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n    )\n\ndef send_with_spinner(name, handle, message):\n    \"\"\"Run AppleScript with a spinner; return (ok, detail).\"\"\"\n    proc = run_osascript(handle, message)\n    spinning = True\n    out = {\"done\": False, \"stdout\": \"\", \"stderr\": \"\"}\n\n    def reader():\n        so, se = proc.communicate()\n        out[\"stdout\"] = (so or \"\").strip()\n        out[\"stderr\"] = (se or \"\").strip()\n        out[\"done\"] = True\n\n    t = threading.Thread(target=reader, daemon=True)\n    t.start()\n\n    i = 0\n    prefix = f\"{DIM}{SPIN[i % len(SPIN)]}{RST} {DIM}sending to{RST} {BOLD}{name}{RST}\"\n    sys.stdout.write(prefix); sys.stdout.flush()\n\n    while not out[\"done\"]:\n        time.sleep(0.08)\n        i += 1\n        prefix = f\"\\r{DIM}{SPIN[i % len(SPIN)]}{RST} {DIM}sending to{RST} {BOLD}{name}{RST}\"\n        sys.stdout.write(prefix); sys.stdout.flush()\n\n    # Clear spinner line\n    sys.stdout.write(\"\\r\"); sys.stdout.flush()\n\n    status = out[\"stdout\"] or out[\"stderr\"]\n    status = status.strip()\n    if proc.returncode == 0 and status and not status.startswith(\"ERROR\"):\n        # iMessage or SMS\n        sys.stdout.write(f\"{GREEN}{CHECK}{RST} {BOLD}{name}{RST} {DIM}[{status}]{RST}\\n\")\n        return True, status\n    else:\n        sys.stdout.write(f\"{RED}{CROSS}{RST} {BOLD}{name}{RST} {DIM}[{status or 'failed'}]{RST}\\n\")\n        return False, status\n\ndef main():\n    targets_str, msg = parse_cli(sys.argv)\n    entries = load_entries()\n    resolved = resolve_targets(targets_str, entries)\n    if not resolved:\n        print(\"[fimg] no recipients resolved\"); sys.exit(3)\n\n    names = [r[0] for r in resolved]\n    if not box_preview(msg, names):\n        print(\"[fimg] cancelled\"); sys.exit(0)\n\n    print(BLUE + BOLD + \"Sending…\" + RST)\n    failures = 0\n    for name, handle in resolved:\n        ok, status = send_with_spinner(name, handle, msg)\n        if not ok:\n            failures += 1\n\n    if failures:\n        print(RED + BOLD + f\"Done with {failures} error(s).\" + RST)\n        sys.exit(1)\n    else:\n        print(GREEN + BOLD + \"All sent.\" + RST)\n\nif __name__ == \"__main__\":\n    main()\n\n"
      }
    ]
  },
  {
    "name": "lib",
    "path": "lib",
    "type": "directory",
    "children": [
      {
        "name": "center.sh",
        "path": "lib/center.sh",
        "type": "file",
        "content": "# lib/center.sh — normalize and measure\n\n# Strip common leading spaces from a multi-line block.\ncenter_normalize() {\n  awk '\n    {buf[NR]=$0; if($0 ~ /[^[:space:]]/){ match($0,/^[[:space:]]*/); l=RLENGTH; if(min==0 || l<min) min=l; }}\n    END{ if(min==\"\") min=0; for(i=1;i<=NR;i++){ s=buf[i]; if(length(s)>min) print substr(s,min+1); else print \"\" } }\n  '\n}\n\n# Max char width of stdin (unicode safe via python3; falls back to awk)\ncenter_width() {\n  if command -v python3 >/dev/null 2>&1; then\n    python3 - <<'PY'\nimport sys\nlines=[l.rstrip(\"\\n\") for l in sys.stdin]\nprint(max((len(x) for x in lines), default=0))\nPY\n  else\n    awk 'length>m{m=length}END{print m+0}'\n  fi\n}\n"
      },
      {
        "name": "layout.sh",
        "path": "lib/layout.sh",
        "type": "file",
        "content": "# lib/layout.sh — center a multi-line block as a single object (unicode-aware width)\n\nblock_width() {\n  # python counts codepoints; good for these block chars\n  python3 - \"$@\" <<'PY'\nimport sys\nlines=[l.rstrip(\"\\n\") for l in sys.stdin]\nprint(max((len(x) for x in lines), default=0))\nPY\n}\n\ncenter_block_draw() {\n  block=\"$1\"\n  gap=\"${2:-0}\" # extra blank lines appended (already in block normally)\n  cols=$(tput cols 2>/dev/null || echo 80)\n  rows=$(tput lines 2>/dev/null || echo 24)\n\n  # split into array, measure\n  IFS='\n' set -f\n  set -- $block\n  lines_list=\"$*\"\n  H=0\n  for _ in $lines_list; do H=$((H + 1)); done\n  W=$(printf '%s\\n' \"$block\" | block_width)\n\n  L=$(((cols - W) / 2))\n  [ \"$L\" -gt 0 ] || L=0\n  T=$(((rows - (H + gap)) / 2))\n  [ \"$T\" -gt 0 ] || T=0\n\n  r=$((T + 1))\n  printf '%s\\n' \"$block\" | while IFS= read -r line; do\n    printf '\\033[%s;%sH%s' \"$r\" $((L + 1)) \"$line\"\n    r=$((r + 1))\n  done\n}\n"
      },
      {
        "name": "resize.sh",
        "path": "lib/resize.sh",
        "type": "file",
        "content": "# lib/resize.sh — simple WINCH hook\nresize_on_redraw() {\n  _cb=\"$1\"\n  trap \"$_cb\" WINCH\n}\n"
      },
      {
        "name": "term.sh",
        "path": "lib/term.sh",
        "type": "file",
        "content": "# lib/term.sh — tiny TTY helpers (POSIX sh)\n\nterm_save() {\n  STTY_OLD=$(stty -g)\n  tput smcup 2>/dev/null || printf '\\033[?1049h'\n  tput civis\n  stty -echo -icanon time 0 min 1\n}\nterm_restore() {\n  stty \"$STTY_OLD\" 2>/dev/null || true\n  tput cnorm\n  tput rmcup 2>/dev/null || printf '\\033[?1049l'\n}\n\nterm_clear() { tput clear 2>/dev/null || printf '\\033[2J\\033[H'; }\n\nterm_size() {\n  C=$(tput cols 2>/dev/null || echo 80)\n  R=$(tput lines 2>/dev/null || echo 24)\n}\n\n# Move to row,col (1-based)\nterm_goto() { printf '\\033[%s;%sH' \"$1\" \"$2\"; }\n\n# Read one key from /dev/tty (works in sh)\nterm_read_key() { dd bs=1 count=1 2>/dev/null </dev/tty; }\n"
      }
    ]
  },
  {
    "name": "scripts",
    "path": "scripts",
    "type": "directory",
    "children": [
      {
        "name": "send_imessage.applescript",
        "path": "scripts/send_imessage.applescript",
        "type": "file",
        "content": "-- send_imessage.applescript\n-- Usage: osascript send_imessage.applescript \"<number or email>\" \"<message>\"\non run argv\n  if (count of argv) < 2 then return\n  set target to item 1 of argv\n  set textMsg to item 2 of argv\n  tell application \"Messages\"\n    activate\n    set theService to first service whose service type is iMessage\n    set theBuddy to buddy target of theService\n    send textMsg to theBuddy\n  end tell\nend run\n\n"
      }
    ]
  },
  {
    "name": "ui",
    "path": "ui",
    "type": "directory",
    "children": [
      {
        "name": "banner.txt",
        "path": "ui/banner.txt",
        "type": "file",
        "content": "    ██████   ███\n   ███▒▒███ ▒▒▒       930\n  ▒███ ▒▒▒  ████  █████████████    ███████\n ███████   ▒▒███ ▒▒███▒▒███▒▒███  ███▒▒███\n▒▒▒███▒     ▒███  ▒███ ▒███ ▒███ ▒███ ▒███\n  ▒███      ▒███  ▒███ ▒███ ▒███ ▒███ ▒███\n  █████     █████ █████▒███ █████▒▒███████\n ▒▒▒▒▒     ▒▒▒▒▒ ▒▒▒▒▒ ▒▒▒ ▒▒▒▒▒  ▒▒▒▒▒███\n                                  ███ ▒███\n                                 ▒▒██████\n                                  ▒▒▒▒▒▒\n\n"
      },
      {
        "name": "commands.sh",
        "path": "ui/commands.sh",
        "type": "file",
        "content": "#!/usr/bin/env sh\n# ui/commands.sh — prints commands; --plain outputs no ANSI for width calc\n\nif [ \"${1-}\" = \"--plain\" ]; then\n  printf 's (send)   d (draft)   S (schedule)   h (help)   q(uit)'\n  exit 0\nfi\n\nif tput colors >/dev/null 2>&1; then\n  B=$(tput bold)\n  R=$(tput sgr0)\n  K=$(tput setaf 6)\n  L=$(tput setaf 7)\nelse\n  B=''\n  R=''\n  K=''\n  L=''\nfi\n\nprintf \"%s%s%s %s(send)%s   %s%s%s %s(draft)%s   %s%s%s %s(schedule)%s   %s%s%s %s(help)%s   %s%s%s%s(uit)%s\" \\\n  \"$B\" \"$K\" s \"$L\" \"$R\" \\\n  \"$B\" \"$K\" d \"$L\" \"$R\" \\\n  \"$B\" \"$K\" S \"$L\" \"$R\" \\\n  \"$B\" \"$K\" h \"$L\" \"$R\" \\\n  \"$B\" \"$K\" q \"$L\" \"$R\"\n"
      },
      {
        "name": "compose_overlay.sh",
        "path": "ui/compose_overlay.sh",
        "type": "file",
        "content": "#!/usr/bin/env sh\n# ui/compose_overlay.sh — centered floating overlay window (no alt-screen)\n# Esc closes; :q closes; :w accepts (exit 0). Cleans up (erases box) on exit.\n\nset -eu\n\n# --- tiny tty helpers (no alternate screen) ---\nsave() {\n  STTY_OLD=$(stty -g)\n  tput civis\n  stty -echo -icanon time 0 min 1\n}\nrest() {\n  stty \"$STTY_OLD\" 2>/dev/null || true\n  tput cnorm\n}\ngoto() { printf '\\033[%s;%sH' \"$1\" \"$2\"; }\nread1() { dd bs=1 count=1 2>/dev/null </dev/tty || true; }\n\n# globals for geometry\nW=0 H=0 L=0 T=0\n\ncompute_geom() {\n  cols=$(tput cols 2>/dev/null || echo 80)\n  rows=$(tput lines 2>/dev/null || echo 24)\n  W=$((cols * 3 / 5))\n  [ \"$W\" -lt 60 ] && W=60\n  [ \"$W\" -gt $((cols - 4)) ] && W=$((cols - 4))\n  H=$((rows * 2 / 5))\n  [ \"$H\" -lt 12 ] && H=12\n  [ \"$H\" -gt $((rows - 4)) ] && H=$((rows - 4))\n  L=$(((cols - W) / 2))\n  T=$(((rows - H) / 2))\n}\n\nerase_box() {\n  compute_geom\n  # erase border area and shadow by painting spaces\n  r=$T\n  while [ $r -le $((T + H)) ]; do\n    goto \"$r\" \"$L\"\n    printf \"%*s\" \"$((W + 1))\" \"\" # +1 covers right border\n    r=$((r + 1))\n  done\n  # erase bottom shadow line\n  goto $((T + H)) $((L + 1))\n  printf \"%*s\" \"$W\" \"\"\n}\n\ndraw_box() {\n  compute_geom\n\n  # subtle shadow (gray)\n  if tput setaf 8 >/dev/null 2>&1; then\n    SH=\"$(tput setaf 8)\"\n    NC=\"$(tput sgr0)\"\n    r=$((T + 1))\n    while [ $r -le $((T + H)) ]; do\n      goto \"$r\" $((L + W))\n      printf \"%s \" \"$SH\"\n      r=$((r + 1))\n    done\n    goto $((T + H)) $((L + 1))\n    printf \"%s%*s%s\" \"$SH\" \"$W\" \"\" \"$NC\"\n  fi\n\n  # border (box-drawing)\n  tl=\"┌\"\n  tr=\"┐\"\n  bl=\"└\"\n  br=\"┘\"\n  hz=\"─\"\n  vt=\"│\"\n  goto \"$T\" \"$L\"\n  printf \"%s%s%s\" \"$tl\" \"$(printf \"%*s\" $((W - 2)) \"\" | tr ' ' \"$hz\")\" \"$tr\"\n  r=$((T + 1))\n  while [ $r -lt $((T + H - 1)) ]; do\n    goto \"$r\" \"$L\"\n    printf \"%s%*s%s\" \"$vt\" $((W - 2)) \"\" \"$vt\"\n    r=$((r + 1))\n  done\n  goto \"$r\" \"$L\"\n  printf \"%s%s%s\" \"$bl\" \"$(printf \"%*s\" $((W - 2)) \"\" | tr ' ' \"$hz\")\" \"$br\"\n\n  # title\n  title=\" Compose  —  :w accept   :q cancel   (Esc closes) \"\n  goto \"$T\" $((L + (W - ${#title}) / 2))\n  printf \"%s\" \"$title\"\n\n  # footer hint\n  goto $((T + H - 1)) $((L + 2))\n  printf \"Type here…\"\n}\n\nmain() {\n  save\n  # ensure cleanup always erases the window and restores tty\n  trap 'erase_box; rest' EXIT\n\n  draw_box\n  MODE=\"INSERT\"\n  CMD=\"\"\n\n  while :; do\n    k=\"$(read1)\"\n    case \"$k\" in\n    \"$(printf '\\e')\") exit 1 ;; # Esc closes overlay\n    :)\n      MODE=\"CMD\"\n      CMD=\"\"\n      ;;                     # enter command mode\n    \"$(printf '\\r')\") : ;;   # ignore Enter (window-only preview)\n    \"$(printf '\\x7f')\") : ;; # ignore Backspace here\n    *) [ \"$MODE\" = \"CMD\" ] && CMD=\"$CMD$k\" ;;\n    esac\n\n    # handle :w / :q on Enter\n    if [ \"$MODE\" = \"CMD\" ] && [ \"$k\" = \"$(printf '\\r')\" ]; then\n      [ \"$CMD\" = \"q\" ] && exit 1\n      [ \"$CMD\" = \"w\" ] && exit 0\n      MODE=\"INSERT\"\n    fi\n  done\n}\nmain \"$@\"\n"
      },
      {
        "name": "landing.sh",
        "path": "ui/landing.sh",
        "type": "file",
        "content": "#!/usr/bin/env sh\n# ui/landing.sh — centered banner; fast menu highlight; j/k + Enter; s opens overlay; q quits\n\n. \"$(dirname \"$0\")/../lib/term.sh\"\n\nmeasure_width() {\n  python3 - <<'PY'\nimport sys\nprint(max((len(l.rstrip(\"\\n\")) for l in sys.stdin), default=0))\nPY\n}\n\n# --- incremental highlight state (0..4 = Send..Quit) ---\nHOVER=0\n_mleft=0 _mtop=0 _mw=0\n\n# Re-highlight a single menu row without redrawing the page\n# $1 = row idx (0..4), $2 = 1 to highlight, 0 to restore colored line\nhilite_line() {\n  idx=\"$1\"\n  on=\"${2:-0}\"\n  r=$((_mtop + 1 + idx))\n  printf '\\033[%s;%sH' \"$r\" $((_mleft + 1))\n  if [ \"$on\" -eq 1 ]; then\n    plain=\"$(\"$(dirname \"$0\")/menu.sh\" --plain | sed -n \"$((idx + 1))p\")\"\n    printf '\\033[7m%-*s\\033[0m' \"$_mw\" \"$plain\"\n  else\n    \"$(dirname \"$0\")/menu.sh\" | sed -n \"$((idx + 1))p\"\n  fi\n}\n\ndraw() {\n  term_clear\n  cols=$(tput cols 2>/dev/null || echo 80)\n  rows=$(tput lines 2>/dev/null || echo 24)\n\n  # --- Banner geometry ---\n  B=\"$(cat \"$(dirname \"$0\")/banner.txt\")\"\n  BW=$(printf '%s\\n' \"$B\" | measure_width)\n  BH=$(printf '%s\\n' \"$B\" | wc -l | tr -d ' ')\n  GAP=3\n  top=$(((rows - (BH + GAP + 5)) / 2))\n  [ \"$top\" -gt 0 ] || top=0\n  left=$(((cols - BW) / 2))\n  [ \"$left\" -gt 0 ] || left=0\n\n  # draw banner once\n  row=$((top + 5))\n  printf '%s\\n' \"$B\" | while IFS= read -r line; do\n    printf '\\033[%s;%sH%s' \"$row\" $((left + 1)) \"$line\"\n    row=$((row + 1))\n  done\n\n  # --- Menu block (remember geometry) ---\n  plain=\"$(\"$(dirname \"$0\")/menu.sh\" --plain)\"\n  _mw=$(printf '%s\\n' \"$plain\" | measure_width)\n  MH=$(printf '%s\\n' \"$plain\" | wc -l | tr -d ' ')\n  OFFSET=15\n  _mleft=$(((cols - _mw) / 2 + OFFSET))\n  [ \"$_mleft\" -gt 0 ] || _mleft=0\n  _mtop=$((top + BH + GAP))\n\n  # draw colored menu once\n  r=$((_mtop + 1))\n  \"$(dirname \"$0\")/menu.sh\" | while IFS= read -r line; do\n    printf '\\033[%s;%sH%s' \"$r\" $((_mleft + 1)) \"$line\"\n    r=$((r + 1))\n  done\n\n  # initial highlight\n  hilite_line \"$HOVER\" 1\n\n  # park cursor off-screen\n  printf '\\033[%s;%sH' \"$rows\" 1\n}\n\nmain() {\n  term_save\n  tput civis 2>/dev/null || true\n  trap 'tput cnorm 2>/dev/null || true; term_restore' EXIT\n\n  HOVER=0\n  draw\n\n  while :; do\n    k=\"$(term_read_key)\"\n    case \"$k\" in\n    q)\n      printf '\\033[2J\\033[H'\n      break\n      ;;\n\n    # vim navigation (incremental highlight only)\n    j)\n      if [ \"$HOVER\" -lt 4 ]; then\n        hilite_line \"$HOVER\" 0\n        HOVER=$((HOVER + 1))\n        hilite_line \"$HOVER\" 1\n      fi\n      ;;\n    k)\n      if [ \"$HOVER\" -gt 0 ]; then\n        hilite_line \"$HOVER\" 0\n        HOVER=$((HOVER - 1))\n        hilite_line \"$HOVER\" 1\n      fi\n      ;;\n\n    # direct hotkeys\n    s)\n      hilite_line \"$HOVER\" 0\n      HOVER=0\n      hilite_line \"$HOVER\" 1\n      /Users/mihir/fimg/ui/compose_overlay.sh </dev/tty >/dev/tty 2>/dev/null\n      draw\n      ;;\n    d)\n      hilite_line \"$HOVER\" 0\n      HOVER=1\n      hilite_line \"$HOVER\" 1\n      ;;\n    S)\n      hilite_line \"$HOVER\" 0\n      HOVER=2\n      hilite_line \"$HOVER\" 1\n      ;;\n    h)\n      hilite_line \"$HOVER\" 0\n      HOVER=3\n      hilite_line \"$HOVER\" 1\n      ;;\n\n    # Enter selects the highlighted row\n    \"$(printf '\\r')\")\n      case \"$HOVER\" in\n      0)\n        /Users/mihir/fimg/ui/compose_overlay.sh </dev/tty >/dev/tty 2>/dev/null\n        draw\n        ;;\n      1) : ;; 2) : ;; 3) : ;;\n      4)\n        printf '\\033[2J\\033[H'\n        break\n        ;;\n      esac\n      ;;\n    *) : ;;\n    esac\n  done\n}\n\nmain \"$@\"\n"
      },
      {
        "name": "menu.sh",
        "path": "ui/menu.sh",
        "type": "file",
        "content": "#!/usr/bin/env sh\n# ui/menu.sh — vertical menu like LazyVim (narrow). --plain prints without ANSI for measuring.\n\n# rows: \"Label|Hotkey\"\nROWS='Send|s\nDraft|d\nSchedule|S\nHelp|h\nQuit|q'\n\nif [ \"${1-}\" = \"--plain\" ]; then\n  echo \"$ROWS\" | awk -F'|' '{ printf \"%-10s %s\\n\", $1, $2 }'\n  exit 0\nfi\n\nif tput colors >/dev/null 2>&1; then\n  B=$(tput bold)\n  R=$(tput sgr0)\n  K=$(tput setaf 6) # hotkey color\n  L=$(tput setaf 7) # label color\nelse\n  B=''\n  R=''\n  K=''\n  L=''\nfi\n\necho \"$ROWS\" | awk -F'|' -v B=\"$B\" -v R=\"$R\" -v K=\"$K\" -v L=\"$L\" '\n{\n  # left label padded to 10; tight single space before key\n  printf \"%s%-10s%s %s%s%s\\n\", L, $1, R, B K, $2, R\n}'\n"
      }
    ]
  }
]
