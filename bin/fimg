#!/usr/bin/env sh
# bin/fimg — explicit flags: -r reload, -c CLI send, -e edit, -h help
set -eu

resolve_dir() {
  tgt=$1
  while [ -L "$tgt" ]; do
    dir=$(cd -P -- "$(dirname -- "$tgt")" && pwd)
    link=$(readlink "$tgt")
    case $link in /*) tgt="$link" ;; *) tgt="$dir/$link" ;; esac
  done
  cd -P -- "$(dirname -- "$tgt")" && pwd
}

SCRIPT_DIR=$(resolve_dir "$0")
ROOT_DIR=$(cd -P -- "$SCRIPT_DIR/.." && pwd)

ENGINE_TEST_PY="$ROOT_DIR/engine/test_send.py"
BLAST_PY="$ROOT_DIR/engine/blast.py"
EDIT_PY="$ROOT_DIR/engine/edit_list.py"
UI_LAUNCH="$ROOT_DIR/ui/landing.sh"

print_help() {
  cat <<EOF
fimg — fast iMessage group

Usage:
  fimg -r
      FULL reload: chmod +x *.sh/*.py; relink /usr/local/bin/fimg; refresh command cache.

  fimg -c [-skip] [all|actives|brothers|pledges] to <names> : <message>
  fimg -c [-skip] [all|actives|brothers|pledges] <names> : <message>
      CLI send (no UI). Use -skip to bypass Enter-to-send prompt for scripting.
      Examples:  fimg -c to bay: yo   |  fimg -c pledges to all: hi

  fimg -e r <list|path>      # remove entries (Tab-complete names; Enter=go, any other key=cancel)
  fimg -e a <list|path>      # add a single entry (name → number → alias)
      <list> may be: pledges | brothers | actives | all, or a CSV path.

  fimg
      Launch UI.
EOF
}

# --- no args: launch UI
[ $# -eq 0 ] && exec "$UI_LAUNCH"

case "${1-}" in
-h | --help)
  print_help
  exit 0
  ;;
-r)
  shift
  echo "[fimg] Reloading…"
  find "$ROOT_DIR" -type f -name '*.sh' -exec chmod +x {} \; || true
  find "$ROOT_DIR" -type f -name '*.py' -exec chmod +x {} \; || true
  # Relink
  WANT="$ROOT_DIR/bin/fimg"
  if sudo ln -sf "$WANT" /usr/local/bin/fimg 2>/dev/null; then :; else
    mkdir -p "$HOME/bin"
    ln -sf "$WANT" "$HOME/bin/fimg"
    case ":$PATH:" in *":$HOME/bin:"*) : ;; *) export PATH="$HOME/bin:$PATH" ;; esac
  fi
  hash -r 2>/dev/null || true
  command -v rehash >/dev/null 2>&1 && rehash || true
  echo "✅ reloaded. which fimg => $(command -v fimg || echo not-found)"
  exit 0
  ;;
-c)
  shift
  [ -x "$BLAST_PY" ] || {
    echo "[fimg] blast not found: $BLAST_PY" >&2
    exit 2
  }
  exec "$BLAST_PY" "$@"
  ;;
-e)
  shift
  [ -f "$EDIT_PY" ] || {
    echo "[fimg] editor not found: $EDIT_PY" >&2
    exit 2
  }
  exec python3 "$EDIT_PY" "$@"
  ;;
*)
  # anything else launches UI (prevents accidental editor invocation)
  exec "$UI_LAUNCH" "$@"
  ;;
esac
